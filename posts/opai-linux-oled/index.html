<!doctype html><html lang=zh-cn><head><title>嵌入式 Linux 外设 [Part 2] -- 点亮屏幕 ::
Horizon Blog Neo</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="在香橙派 R1+ LTS 上使用 I2C 点亮 OLED 屏幕和 1602 LCD # 在 上一篇文章 中, 我们成功通过 I2C 接口读到了传感器的数据. 光有输入怎么行, 接下来哦我们继续利用 I2C 接口整点输"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://horizonchaser.github.io/neo/posts/opai-linux-oled/><link rel=stylesheet href=/neo/css/style.css><link rel=stylesheet href=https://horizonchaser.github.io/neo/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://horizonchaser.github.io/neo/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://horizonchaser.github.io/neo/img/favicon.png><link href=/neo/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/neo/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/neo/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/neo/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/neo/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/neo/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="嵌入式 Linux 外设 [Part 2] -- 点亮屏幕"><meta name=twitter:description content="之前我们跑通了硬件的 I2C, 接下来我们试着用 I2C 去点亮屏幕吧"><meta property="og:title" content="嵌入式 Linux 外设 [Part 2] -- 点亮屏幕"><meta property="og:description" content="之前我们跑通了硬件的 I2C, 接下来我们试着用 I2C 去点亮屏幕吧"><meta property="og:type" content="article"><meta property="og:url" content="https://horizonchaser.github.io/neo/posts/opai-linux-oled/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-11T15:55:06+08:00"><meta property="article:modified_time" content="2024-01-12T23:24:45+08:00"><meta property="og:site_name" content="Horizon Blog Neo"></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=/neo class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>Horizon Blog Neo</span>
<span class=logo__cursor></span></a>
<span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/neo/index.xml>RSS</a></li><li><a href=/neo/about/>关于</a></li><li><a href=/neo/links/>友链</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/neo/index.xml>RSS</a></li><li><a href=/neo/about/>关于</a></li><li><a href=/neo/links/>友链</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><article class=post><h1 class=post-title>嵌入式 Linux 外设 [Part 2] &ndash; 点亮屏幕</h1><div class=post-meta><time class=post-date>2024-01-11</time>
<span class=post-moddate>(最后修改于：
2024-01-12)</span></div><div class=post-content><h1 id=在香橙派-r1-lts-上使用-i2c-点亮-oled-屏幕和-1602-lcd>在香橙派 R1+ LTS 上使用 I2C 点亮 OLED 屏幕和 1602 LCD
<a href=#%e5%9c%a8%e9%a6%99%e6%a9%99%e6%b4%be-r1-lts-%e4%b8%8a%e4%bd%bf%e7%94%a8-i2c-%e7%82%b9%e4%ba%ae-oled-%e5%b1%8f%e5%b9%95%e5%92%8c-1602-lcd class=h-anchor aria-hidden=true>#</a></h1><p>在 <a href=https://horizonchaser.github.io/neo/posts/opai-linux-gpio/>上一篇文章</a> 中, 我们成功通过 I2C 接口读到了传感器的数据. 光有输入怎么行, 接下来哦我们继续利用 I2C 接口整点输出, 比如&mldr;点亮显示屏!</p><p>正好今天显示屏终于到了, 一块儿 0.91 英寸的 128x32 OLED, 一块儿 1602 LCD, 以及转到 I2C 接口的转接板. 接下来就开干!</p><h2 id=点亮-oled-屏幕>点亮 OLED 屏幕
<a href=#%e7%82%b9%e4%ba%ae-oled-%e5%b1%8f%e5%b9%95 class=h-anchor aria-hidden=true>#</a></h2><p>手头这块儿 OLED 屏幕驱动芯片是 <code>SSD1306</code>, 具体的原理暂时先略过, 可以直接使用 <code>luma.oled</code> 库操作 (记得先安装).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> luma.core.interface.serial <span style=color:#f92672>import</span> i2c
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> luma.core.render <span style=color:#f92672>import</span> canvas
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> luma.oled.device <span style=color:#f92672>import</span> ssd1306
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> time
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 创建 I2C 设备, SSD1306 默认地址是 0x3C</span>
</span></span><span style=display:flex><span>serial <span style=color:#f92672>=</span> i2c(port<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, address<span style=color:#f92672>=</span><span style=color:#ae81ff>0x3C</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 创建屏幕的驱动实例</span>
</span></span><span style=display:flex><span>device <span style=color:#f92672>=</span> ssd1306(serial, width<span style=color:#f92672>=</span><span style=color:#ae81ff>128</span>, height<span style=color:#f92672>=</span><span style=color:#ae81ff>32</span>, rotate<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 开始往屏幕上绘图</span>
</span></span><span style=display:flex><span><span style=color:#75715e># draw 是 Pillow 的实例, 它里面还有非常多的绘图 API</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> canvas(device) <span style=color:#66d9ef>as</span> draw:
</span></span><span style=display:flex><span>  draw<span style=color:#f92672>.</span>rectangle(device<span style=color:#f92672>.</span>bounding_box, outline<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;white&#34;</span>, fill<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;black&#34;</span>)
</span></span><span style=display:flex><span>  draw<span style=color:#f92672>.</span>text((<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>40</span>), <span style=color:#e6db74>&#34;Hello World&#34;</span>, fill<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;white&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># luma 在退出时会自动调用一次清屏, 速度太快会导致我们什么也看不到</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 所以需要等待</span>
</span></span><span style=display:flex><span>time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>1000</span>)
</span></span></code></pre></div><p>接线还是和之前一样, 不再赘述. 对设备的操作需要 root 权限, 如果一切正常, 你应当能看到屏幕四周有白色矩形, 内部就是 &ldquo;Hello World&rdquo;.</p><h3 id=让屏幕动起来>让屏幕动起来
<a href=#%e8%ae%a9%e5%b1%8f%e5%b9%95%e5%8a%a8%e8%b5%b7%e6%9d%a5 class=h-anchor aria-hidden=true>#</a></h3><p>为了测试一下显示屏在 I2C 总线上的响应速度, 画个大的进度条试试:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> luma.core.interface.serial <span style=color:#f92672>import</span> i2c
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> luma.core.render <span style=color:#f92672>import</span> canvas
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> luma.oled.device <span style=color:#f92672>import</span> ssd1306
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> time
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 创建 I2C 设备, SSD1306 默认地址是 0x3C</span>
</span></span><span style=display:flex><span>serial <span style=color:#f92672>=</span> i2c(port<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, address<span style=color:#f92672>=</span><span style=color:#ae81ff>0x3C</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 创建屏幕的驱动实例</span>
</span></span><span style=display:flex><span>device <span style=color:#f92672>=</span> ssd1306(serial, width<span style=color:#f92672>=</span><span style=color:#ae81ff>128</span>, height<span style=color:#f92672>=</span><span style=color:#ae81ff>32</span>, rotate<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 通过不断向右侧扩展的矩形来作为进度条</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>128</span>):
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>with</span> canvas(device) <span style=color:#66d9ef>as</span> draw:
</span></span><span style=display:flex><span>    draw<span style=color:#f92672>.</span>rectangle((<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,i,<span style=color:#ae81ff>31</span>), fill<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;white&#34;</span>, outline<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;white&#34;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;curr col: </span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>0.001</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 这里不再等待, 直接退出</span>
</span></span></code></pre></div><p>同样以 root 权限执行, 通过 <code>time</code> 命令可以看到需要 7.8 秒才能执行完&mldr; 这速度还是太慢了. 如果需要高速刷新的话, 可以使用 SPI 总线操作.</p><h2 id=点亮-1602-lcd-屏幕>点亮 1602 LCD 屏幕
<a href=#%e7%82%b9%e4%ba%ae-1602-lcd-%e5%b1%8f%e5%b9%95 class=h-anchor aria-hidden=true>#</a></h2><p>1602 本身并不是 I2C 接口的, 不过通过转接模块, 我们可以将其转为 I2C 接口操作. 这不仅能极大的简化我们的操作, 还能省下很多 I/O 接口.</p><h3 id=转接的原理>转接的原理
<a href=#%e8%bd%ac%e6%8e%a5%e7%9a%84%e5%8e%9f%e7%90%86 class=h-anchor aria-hidden=true>#</a></h3><p>转接板的核心是一块儿 <code>PCF8574</code> 芯片, 它可以将 I2C 总线操作转为 8 位的 IO 输出 &ndash; 而 1602 本身恰好就是 8 条数据线. 因此我们通过 I2C 总线向转接板写数据, 实质上也就是在直接操作 1602 的数据线. 1602 的指令格式不再赘述, 很容易就能查到.</p><p>除了 8 位的数据线, 转接板还提供了 LCD 背光的供电, 以及对比度调节. 这些都极大的简化了我们的接线 &ndash; 1602 原本需要十几个接口, 但现在和其他 I2C 设备一样, 只需要正负供电和 SCL SDA 四条线即可.</p><h3 id=点亮>点亮
<a href=#%e7%82%b9%e4%ba%ae class=h-anchor aria-hidden=true>#</a></h3><p>1602 的 I2C 接口版本也有很多现成的实现, 例如 <a href=https://pypi.org/project/i2clcd/><code>i2clcd</code></a>. 其实只要阅读库的源代码, 就可以发现它实际上也是直接向对应的 I2C 地址写指令, <a href=https://github.com/WuSiYu/python-i2clcd/blob/master/i2clcd/__init__.py#L111>比如设置背光</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>set_backlight</span>(self, on_off):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Set whether the LCD backlight is on or off
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>_backlight <span style=color:#f92672>=</span> on_off
</span></span><span style=display:flex><span>    i2c_data <span style=color:#f92672>=</span> (self<span style=color:#f92672>.</span>_last_data <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xF7</span>) <span style=color:#f92672>+</span> self<span style=color:#f92672>.</span>_backlight <span style=color:#f92672>*</span> <span style=color:#ae81ff>0x08</span>
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>_i2c_write(i2c_data)
</span></span></code></pre></div><p>直接运行官方例程, 轻松点亮~</p><h2 id=总结>总结
<a href=#%e6%80%bb%e7%bb%93 class=h-anchor aria-hidden=true>#</a></h2><p>没啥好总结的, 调通 I2C 接口之后点亮屏幕并没有什么难度 (但不妨碍我水一篇 :).</p><p>不过不得不说的是, 这 OLED 屏幕也太小了, 本来是打算拿来显示软路由的 IP 和状态的, 这下害得靠 1602 了&mldr;</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>阅读其它文章</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://horizonchaser.github.io/neo/posts/horios-part1/><span class=button__icon>←</span>
<span class=button__text>HoriOS Part01 -- 实现一个简单的 UEFI Shell 和 Bootloader</span></a></span>
<span class="button next"><a href=https://horizonchaser.github.io/neo/posts/opai-linux-gpio/><span class=button__text>嵌入式 Linux 外设 [Part 1] -- GPIO 与 I2C</span>
<span class=button__icon>→</span></a></span></div></div><script src=https://giscus.app/client.js data-repo=HorizonChaser/neo data-repo-id=R_kgDOLDDwZQ data-category=Announcements data-category-id=DIC_kwDOLDDwZc4CcVGj data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></div><footer class=footer><div class=footer__inner><a href=/neo class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>Horizon Blog Neo</span>
<span class=logo__cursor></span></a><div class=copyright><span>© 2024 Powered by <a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span><a href=https://github.com/panr/hugo-theme-hello-friend target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div><div><span><center><a href="https://icp.gov.moe/?keyword=20243141" target=_blank>萌ICP备20243141号</a></center></span></div></footer><script type=text/javascript src=/neo/bundle.min.js></script></div></body></html>