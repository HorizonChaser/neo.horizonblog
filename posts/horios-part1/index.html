<!doctype html><html lang=zh-cn><head><title>HoriOS Part01 -- 实现一个简单的 UEFI Shell 和 Bootloader ::
Horizon Blog Neo</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="HoriOS Part01: UEFI Shell &amp;amp; bootloader # 这篇文章已经咕咕咕好几天了, 绝对不是因为幻兽帕鲁太好玩了什么的 (捂脸 不过至少现在是开始写了, 大概 关于 HoriOS Project # HoriOS 是一个 (还没开始写"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://horizonchaser.github.io/neo/posts/horios-part1/><link rel=stylesheet href=/neo/css/style.css><link rel=stylesheet href=https://horizonchaser.github.io/neo/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://horizonchaser.github.io/neo/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://horizonchaser.github.io/neo/img/favicon.png><link href=/neo/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/neo/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/neo/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/neo/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/neo/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/neo/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="HoriOS Part01 -- 实现一个简单的 UEFI Shell 和 Bootloader"><meta name=twitter:description content="尝试写一个基于 UEFI 的 x64 下的操作系统, 先从 UEFI 本身开始, 写一个简单的 Shell 和引导程序来了解 UEFI API 吧!"><meta property="og:title" content="HoriOS Part01 -- 实现一个简单的 UEFI Shell 和 Bootloader"><meta property="og:description" content="尝试写一个基于 UEFI 的 x64 下的操作系统, 先从 UEFI 本身开始, 写一个简单的 Shell 和引导程序来了解 UEFI API 吧!"><meta property="og:type" content="article"><meta property="og:url" content="https://horizonchaser.github.io/neo/posts/horios-part1/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-21T22:30:39+08:00"><meta property="article:modified_time" content="2024-03-03T22:49:09+08:00"><meta property="og:site_name" content="Horizon Blog Neo"></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=/neo class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>Horizon Blog Neo</span>
<span class=logo__cursor></span></a>
<span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/neo/index.xml>RSS</a></li><li><a href=/neo/about/>关于</a></li><li><a href=/neo/links/>友链</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/neo/index.xml>RSS</a></li><li><a href=/neo/about/>关于</a></li><li><a href=/neo/links/>友链</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><article class=post><h1 class=post-title>HoriOS Part01 &ndash; 实现一个简单的 UEFI Shell 和 Bootloader</h1><div class=post-meta><time class=post-date>2024-01-21</time>
<span class=post-moddate>(最后修改于：
2024-03-03)</span></div><div class=post-content><h1 id=horios-part01-uefi-shell--bootloader>HoriOS Part01: UEFI Shell & bootloader
<a href=#horios-part01-uefi-shell--bootloader class=h-anchor aria-hidden=true>#</a></h1><p>这篇文章已经咕咕咕好几天了, <del>绝对不是因为幻兽帕鲁太好玩了什么的 (捂脸</del></p><p>不过至少现在是开始写了, 大概</p><h2 id=关于-horios-project>关于 HoriOS Project
<a href=#%e5%85%b3%e4%ba%8e-horios-project class=h-anchor aria-hidden=true>#</a></h2><p>HoriOS 是一个 (还没开始写的) 基于 x64 (或者 RISC-V) 与 UEFI 的, 支持多任务与虚拟内存的, 带有一个 Shell (以及相应的工具) 的玩具操作系统. 也许会支持文件系统和网络这些东西.</p><h2 id=uefi-环境>UEFI 环境
<a href=#uefi-%e7%8e%af%e5%a2%83 class=h-anchor aria-hidden=true>#</a></h2><p>UEFI 和传统的 BIOS (也许这里应该称作CSM) 的功能类似, 不过比起后者的历史包袱要小得多 &ndash; 可以直接以 C 语言调用其提供的 API, 比写汇编什么的好多了. UEFI 本身的标准是开放的, 在 <a href=uefi.org>uefi.org</a> 上可以直接找到.</p><p>UEFI 提供的 &ldquo;功能&rdquo; 被称作协议 (protocol), 一部分协议会在系统表 (<code>EFI_SYSTEM_TABLE</code>, 这是一个大的结构体, 也许可以理解为平台本身, 因为几乎所有的协议都需要系统表作为参数) 中提供. 而其余的协议, 则需要通过协议本身的 UUID 以及一个函数获取入口.</p><p>UEFI 的可执行程序本身就是 <a href=https://learn.microsoft.com/en-us/windows/win32/debug/pe-format>PE32+</a> 的格式 (大概是因为 UEFI 的前身 EFI 是来自安腾那边, 微软和英特尔一起搞的吧), 对于 GCC, <code>--subsystem,10</code> 即可指定该格式. UEFI 程序的入口固定是 <code>efi_main</code>, 需要手动指定; 由于我们不需要标准的库和头文件, 所以还需要 <code>-nostdinc -nostdlib</code>. 其余的参数就和普通的程序没有区别了.</p><h2 id=实现一个-uefi-下的-shell>实现一个 UEFI 下的 Shell
<a href=#%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa-uefi-%e4%b8%8b%e7%9a%84-shell class=h-anchor aria-hidden=true>#</a></h2><blockquote><p>To be noticed, 这里讨论的主题不是 UEFI Shell (UEFI 自带的 Shell), 而是在 UEFI 环境下实现一个它的类似物.</p></blockquote><h3 id=文本的输入输出>文本的输入输出
<a href=#%e6%96%87%e6%9c%ac%e7%9a%84%e8%be%93%e5%85%a5%e8%be%93%e5%87%ba class=h-anchor aria-hidden=true>#</a></h3><p>为了实现 Shell, 我们需要实现两样东西: 文本输入和输出. 幸运的是, 这两个协议都在系统表中有定义, 这样调用起来就方便很多. <a href=https://blog.gztime.cc/posts/2022/2430028/>系统表的定义</a> 如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>  EFI_TABLE_HEADER                 Hdr;
</span></span><span style=display:flex><span>  CHAR16                           <span style=color:#f92672>*</span>FirmwareVendor;
</span></span><span style=display:flex><span>  UINT32                           FirmwareRevision;
</span></span><span style=display:flex><span>  EFI_HANDLE                       ConsoleInHandle;
</span></span><span style=display:flex><span>  EFI_SIMPLE_TEXT_INPUT_PROTOCOL   <span style=color:#f92672>*</span>ConIn;
</span></span><span style=display:flex><span>  EFI_HANDLE                       ConsoleOutHandle;
</span></span><span style=display:flex><span>  EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL  <span style=color:#f92672>*</span>ConOut;
</span></span><span style=display:flex><span>  EFI_HANDLE                       StandardErrorHandle;
</span></span><span style=display:flex><span>  EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL  <span style=color:#f92672>*</span>StdErr;
</span></span><span style=display:flex><span>  EFI_RUNTIME_SERVICES             <span style=color:#f92672>*</span>RuntimeServices;
</span></span><span style=display:flex><span>  EFI_BOOT_SERVICES                <span style=color:#f92672>*</span>BootServices;
</span></span><span style=display:flex><span>  UINTN                            NumberOfTableEntries;
</span></span><span style=display:flex><span>  EFI_CONFIGURATION_TABLE          <span style=color:#f92672>*</span>ConfigurationTable;
</span></span><span style=display:flex><span>} EFI_SYSTEM_TABLE;
</span></span></code></pre></div><p>可以看到, 我们需要的文本输入和输出都在系统表中提供了. <code>EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL</code> 本身也是一个结构体, <a href=https://uefi.org/specs/UEFI/2.10/12_Protocols_Console_Support.html#efi-simple-text-output-protocol>定义</a>) 如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> _EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL {
</span></span><span style=display:flex><span> EFI_TEXT_RESET                           Reset;
</span></span><span style=display:flex><span> EFI_TEXT_STRING                          OutputString;
</span></span><span style=display:flex><span> EFI_TEXT_TEST_STRING                     TestString;
</span></span><span style=display:flex><span> EFI_TEXT_QUERY_MODE                      QueryMode;
</span></span><span style=display:flex><span> EFI_TEXT_SET_MODE                        SetMode;
</span></span><span style=display:flex><span> EFI_TEXT_SET_ATTRIBUTE                   SetAttribute;
</span></span><span style=display:flex><span> EFI_TEXT_CLEAR_SCREEN                    ClearScreen;
</span></span><span style=display:flex><span> EFI_TEXT_SET_CURSOR_POSITION             SetCursorPosition;
</span></span><span style=display:flex><span> EFI_TEXT_ENABLE_CURSOR                   EnableCursor;
</span></span><span style=display:flex><span> SIMPLE_TEXT_OUTPUT_MODE                  <span style=color:#f92672>*</span>Mode;
</span></span><span style=display:flex><span>} EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL;
</span></span></code></pre></div><p>东西真多, 但我们暂时只需要关注 <code>OutputString</code>, 它的定义如下 (我保证这是在输出部分的最后一次):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>EFI_STATUS</span>
</span></span><span style=display:flex><span>(EFIAPI <span style=color:#f92672>*</span>EFI_TEXT_STRING) (
</span></span><span style=display:flex><span> IN EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL    <span style=color:#f92672>*</span>This,
</span></span><span style=display:flex><span> IN CHAR16                             <span style=color:#f92672>*</span>String
</span></span><span style=display:flex><span> );
</span></span></code></pre></div><p>还是很直观的, <code>This</code> 是指向输出协议自己的指针, <code>String</code> 就是要输出的字符串, 以 <code>\0</code> 结尾. <code>CHAR16</code> 说明这是个 UCS-2 编码的 Unicode 字符串 (不过特定的 UEFI 实现本身可能并不支持输出 Unicode 中的全部字符&mldr; QEMU 的 TianoCore 就不支持中文).</p><p>和在其它语言中一样, 输入总是比输出复杂一些. <code>EFI_SIMPLE_TEXT_INPUT_PROTOCOL</code> 定义如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> _EFI_SIMPLE_TEXT_INPUT_PROTOCOL {
</span></span><span style=display:flex><span> EFI_INPUT_RESET                       Reset;
</span></span><span style=display:flex><span> EFI_INPUT_READ_KEY                    ReadKeyStroke;
</span></span><span style=display:flex><span> EFI_EVENT                             WaitForKey;
</span></span><span style=display:flex><span>} EFI_SIMPLE_TEXT_INPUT_PROTOCOL;
</span></span></code></pre></div><p><code>ReadKeyStroke</code> 函数可以让我们获得在按下一个按键时的输入, 不过它是非阻塞的, 在没有按键按下的时候会返回 <code>EFI_NOT_READY</code>, 反之返回的是 <code>EFI_SUCCESS</code> (值为 0). 它通过一个 <code>EFI_INPUT_KEY</code> 类型的指针参数传回按键值, 定义如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> EFI_INPUT_KEY {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> ScanCode;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> UnicodeChar;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>可以看到输入值分为了两部分, <code>ScanCode</code> 对应那些不在 Unicode 范围内的按键, 比如 Esc 键什么的, 当输入值为 Unicode 范围内时其值为零; 反之对 <code>UnicodeChar</code> 同理.</p><p>有一个细节需要注意, UEFI 中的输入默认不会回显, 也就是说如果程序不主动输出, 用户看不到自己输入. 因此如果在我们的 Shell 中不主动进行回显, 用户可能会非常困惑.</p><h3 id=shell-repl>Shell: REPL
<a href=#shell-repl class=h-anchor aria-hidden=true>#</a></h3><blockquote><p>REPL: Read, Evaluate, Print Loop, 即"读取, 求值, 打印"的循环</p></blockquote><p>简单起见, 我们的 Shell 本质上就是一个大的 (无限) 循环.</p><ol><li>读取用户的按键, 回显到屏幕上, 直到用户按下回车键, 完成一条输入</li><li>解析输入内容, 然后执行对应的操作</li><li>打印操作的结果 (如果有的话)</li><li>回到读取的状态 1</li></ol></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>阅读其它文章</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://horizonchaser.github.io/neo/posts/mesa-driver-breaks-vmware/><span class=button__icon>←</span>
<span class=button__text>Mesa Driver Breaks VMWare</span></a></span>
<span class="button next"><a href=https://horizonchaser.github.io/neo/posts/opai-linux-oled/><span class=button__text>嵌入式 Linux 外设 [Part 2] -- 点亮屏幕</span>
<span class=button__icon>→</span></a></span></div></div><script src=https://giscus.app/client.js data-repo=HorizonChaser/neo data-repo-id=R_kgDOLDDwZQ data-category=Announcements data-category-id=DIC_kwDOLDDwZc4CcVGj data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></div><footer class=footer><div class=footer__inner><a href=/neo class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>Horizon Blog Neo</span>
<span class=logo__cursor></span></a><div class=copyright><span>© 2024 Powered by <a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span><a href=https://github.com/panr/hugo-theme-hello-friend target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div><div><span><center><a href="https://icp.gov.moe/?keyword=20243141" target=_blank>萌ICP备20243141号</a></center></span></div></footer><script type=text/javascript src=/neo/bundle.min.js></script></div></body></html>